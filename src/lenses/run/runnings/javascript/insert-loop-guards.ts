/**
 * Loop Guard Injection System
 *
 * Prevents infinite loops in user-submitted JavaScript code by automatically injecting
 * iteration counters and safety checks into loop constructs during AST transformation.
 *
 * The system works by:
 * 1. Parsing code into an Abstract Syntax Tree (AST) using recast
 * 2. Walking the AST to find all loop constructs (for, while, do-while, for-in, for-of)
 * 3. Injecting counter variables and safety checks at the beginning of each loop body
 * 4. Throwing RangeError when loop iteration limits are exceeded
 *
 * This approach allows safe execution of user code in educational contexts without
 * browser freezing due to accidental infinite loops.
 */

import * as recast from 'recast';
import { walk } from 'estree-walker';
import type { Node } from 'estree';

// =============================================================================
// Loop Guard Types (inline for single-file utility)
// =============================================================================

/**
 * Input type for loop guard insertion - accepts either raw code string or parsed AST
 */
type CodeInput = string | Node;

/**
 * Output type for loop guard insertion - returns either processed code string or modified AST
 */
type CodeOutput = string | Node;

/**
 * Generated loop guard components containing variable declaration and check statements
 */
interface LoopGuardComponents {
	/** Variable declaration statement for loop counter (e.g., `let loopGuard_1 = 0;`) */
	variable: Node;
	/** Array of check statements to insert at loop start */
	check: Node[];
}

/**
 * Extended AST node with additional properties for tracking processing state
 */
interface ExtendedNode extends Omit<Node, 'type'> {
	/** Node type identifier */
	type: string;
	/** Marks nodes as generated by loop guard system to prevent double-processing */
	generated?: boolean;
	/** Marks nodes as already visited during AST traversal */
	visited?: boolean;
}

// =============================================================================
// Core Loop Guard Implementation
// =============================================================================

/**
 * Creates a block statement from one or more body statements
 *
 * Ensures that single-statement loop bodies are wrapped in proper block statements
 * to allow for safe insertion of loop guard checks.
 *
 * @param body - Variable number of AST statements to include in the block
 * @returns BlockStatement AST node containing the provided statements
 *
 * @example
 * // Converts: if (condition) statement;
 * // To: if (condition) { statement; }
 */
const blockify = (...body: Node[]): Node => {
	const blockStatement = recast.parse('{}').program.body[0];
	(blockStatement as any).body = body;
	return blockStatement;
};

/**
 * Generates loop guard components for a specific loop iteration
 *
 * Creates both the counter variable declaration and the safety check statements
 * that will be injected into the loop body to prevent infinite iterations.
 *
 * @param id - Unique identifier for this loop guard (e.g., 1, 2, 3)
 * @param max - Maximum allowed iterations before throwing RangeError
 * @returns Object containing variable declaration and check statements
 *
 * @example
 * generateLoopGuard(1, 1000) produces:
 * - Variable: let loopGuard_1 = 0;
 * - Check: loopGuard_1++; if (loopGuard_1 > 1000) { throw new RangeError(...); }
 */
const generateLoopGuard = (id: number, max: number): LoopGuardComponents => {
	// Create counter variable declaration: let loopGuard_${id} = 0;
	const variable = recast.parse(`let loopGuard_${id} = 0;`).program.body[0];
	(variable as ExtendedNode).generated = true;

	// Create safety check code block
	const checkCode = `
    loopGuard_${id}++;
    if (loopGuard_${id} > ${max}) {
      throw new RangeError("loopGuard_${id} is greater than ${max}");
    }
  `;

	// Parse check statements and mark as generated
	const check = recast.parse(checkCode).program.body;
	check.forEach((stmt: any) => ((stmt as ExtendedNode).generated = true));

	return {
		variable,
		check,
	};
};

// =============================================================================
// Main Loop Guard Insertion Function
// =============================================================================

/**
 * Inserts loop guards into JavaScript code to prevent infinite loops
 *
 * This is the main entry point for the loop guard system. It accepts either
 * raw JavaScript code as a string or a pre-parsed AST, processes all loop
 * constructs, and returns the modified code/AST with safety guards injected.
 *
 * The function automatically detects and handles:
 * - for loops (C-style: for(init; condition; update))
 * - while loops
 * - do-while loops
 * - for-in loops (for(key in object))
 * - for-of loops (for(value of iterable))
 *
 * @param evalCode - Input JavaScript code as string or parsed AST
 * @param maxIterations - Maximum allowed loop iterations before throwing error
 * @returns Modified code/AST with loop guards inserted, or original if no loops found
 *
 * @throws {RangeError} At runtime when loop iteration limit exceeded
 *
 * @example
 * ```typescript
 * const unsafeCode = `
 *   while (true) {
 *     console.log('infinite loop!');
 *   }
 * `;
 *
 * const safeCode = insertLoopGuards(unsafeCode, 100);
 * // Result includes automatic loop counter and safety check
 * ```
 */
export const insertLoopGuards = (
	evalCode: CodeInput,
	maxIterations: number
): CodeOutput => {
	// Parse input if it's a string, otherwise use the provided AST
	const ast =
		typeof evalCode === 'object' ? evalCode : recast.parse(evalCode);

	let hasLoops = false;
	let loopNumber = 1;

	// Walk the AST and transform all loop constructs
	const guardedTree = (walk as any)(ast, {
		enter(node: any) {
			// Skip nodes that are generated or already processed
			if (node.generated || node.visited) {
				(this as any).skip();
			}
		},

		leave(node: any, parent: any, _prop: string | number, _index: number) {
			// Only process loop statement types
			if (
				node.type !== 'WhileStatement' &&
				node.type !== 'ForStatement' &&
				node.type !== 'ForOfStatement' &&
				node.type !== 'ForInStatement' &&
				node.type !== 'DoWhileStatement'
			) {
				return;
			}

			hasLoops = true;

			// Generate unique loop guard for this loop
			const { variable, check } = generateLoopGuard(
				loopNumber,
				maxIterations
			);

			// Ensure loop body is a block statement for safe insertion
			if (
				(node as any).body &&
				(node as any).body.type !== 'BlockStatement'
			) {
				(node as any).body = blockify((node as any).body);
			}

			// Insert safety checks at the beginning of loop body
			(node as any).body.body.unshift(...check);

			// Insert counter variable declaration before the loop
			const indexOfNode = parent.body.indexOf(node);
			parent.body.splice(indexOfNode, 0, variable);

			// Mark this node as processed
			node.visited = true;
			loopNumber++;
		},
	});

	// Return appropriate format based on input type
	const guarded: CodeOutput =
		typeof evalCode === 'object'
			? (guardedTree as Node)
			: recast.print(guardedTree as any).code;

	// Only return modified code if loops were actually found and processed
	return hasLoops ? guarded : evalCode;
};

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Type guard to check if a node represents a loop construct
 *
 * @param node - AST node to check
 * @returns True if node is any type of loop statement
 */
export const isLoopNode = (node: Node): boolean => {
	return [
		'WhileStatement',
		'ForStatement',
		'ForOfStatement',
		'ForInStatement',
		'DoWhileStatement',
	].includes(node.type);
};

/**
 * Counts the number of loop constructs in provided code
 *
 * Useful for determining if loop guard processing is needed before
 * running the full transformation.
 *
 * @param code - JavaScript code to analyze
 * @returns Number of loop constructs found
 */
export const countLoops = (code: string): number => {
	try {
		const ast = recast.parse(code);
		let count = 0;

		walk(ast, {
			enter(node: Node) {
				if (isLoopNode(node)) {
					count++;
				}
			},
		});

		return count;
	} catch {
		return 0;
	}
};
